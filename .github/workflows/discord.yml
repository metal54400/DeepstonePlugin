name: Build + Discord + Draft Release (Jar version)

on:
  push:
    branches: ["main", "master"]

  release:
    types: [published]

  workflow_dispatch:
    inputs:
      prerelease:
        description: "Release en prerelease ? (true/false)"
        required: false
        default: "false"
      upload_jar:
        description: "Attacher le jar √† la release ? (true/false)"
        required: false
        default: "true"
      tag_prefix_v:
        description: "Pr√©fixer le tag par 'v' ? (true/false)"
        required: false
        default: "true"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      gradle_version: ${{ steps.meta.outputs.gradle_version }}
      tag_version: ${{ steps.meta.outputs.tag_version }}
      jar_name: ${{ steps.meta.outputs.jar_name }}
      jar_path: ${{ steps.meta.outputs.jar_path }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - uses: gradle/actions/setup-gradle@v3

      - name: Prepare Gradle Wrapper
        shell: bash
        run: |
          chmod +x ./gradlew
          sed -i 's/\r$//' ./gradlew

      - name: Build (Gradle)
        run: ./gradlew clean build

      - name: Resolve jar + version
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          # version Gradle (doit √™tre la m√™me que celle dans le jar)
          V="$(./gradlew -q printVersion | tail -n 1 | tr -d '[:space:]')"
          if [ -z "$V" ]; then
            echo "Version Gradle vide (printVersion)."
            exit 1
          fi

          # Choisir le jar "principal"
          # Exclut plain/sources/javadoc
          JAR="$(ls -1 build/libs/*.jar 2>/dev/null \
            | grep -Ev '(-plain|-sources|-javadoc)\.jar$' \
            | head -n 1 || true)"

          if [ -z "$JAR" ]; then
            echo "Aucun jar principal trouv√© dans build/libs."
            ls -la build/libs || true
            exit 1
          fi

          JAR_NAME="$(basename "$JAR")"

          # V√©rifie que le nom du jar contient la version
          if ! echo "$JAR_NAME" | grep -q "$V"; then
            echo "Attention: le jar '$JAR_NAME' ne contient pas la version '$V'."
            echo "=> Configure archiveBaseName/archiveVersion dans Gradle."
            exit 1
          fi

          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ inputs.tag_prefix_v }}" = "true" ]; then
            TAG="v$V"
          else
            TAG="v$V"
          fi

          echo "gradle_version=$V" >> "$GITHUB_OUTPUT"
          echo "tag_version=$TAG" >> "$GITHUB_OUTPUT"
          echo "jar_name=$JAR_NAME" >> "$GITHUB_OUTPUT"
          echo "jar_path=$JAR" >> "$GITHUB_OUTPUT"

          echo "Version: $V"
          echo "Tag: $TAG"
          echo "Jar: $JAR_NAME"

      - name: Upload artifact (JAR)
        uses: actions/upload-artifact@v4
        with:
          name: jar
          path: ${{ steps.meta.outputs.jar_path }}
          if-no-files-found: error

  draft_release:
    runs-on: ubuntu-latest
    needs: build
    if: ${{ github.event_name == 'workflow_dispatch' && needs.build.result == 'success' }}
    steps:
      - uses: actions/checkout@v4

      - name: Download jar artifact
        if: ${{ inputs.upload_jar == 'true' }}
        uses: actions/download-artifact@v4
        with:
          name: jar
          path: dist

      - name: Check if tag already exists (ignore if yes)
        id: tagcheck
        shell: bash
        env:
          TAG: ${{ needs.build.outputs.tag_version }}
        run: |
          set -euo pipefail
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG$"; then
            echo "Tag $TAG existe d√©j√† ‚Üí on ignore."
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create tag + Draft release (tag = jar version)
        if: ${{ steps.tagcheck.outputs.exists != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.build.outputs.tag_version }}
          PRERELEASE: ${{ inputs.prerelease }}
          UPLOAD_JAR: ${{ inputs.upload_jar }}
          JAR_NAME: ${{ needs.build.outputs.jar_name }}
        shell: bash
        run: |
          set -euo pipefail

          args=( "$TAG" --draft --generate-notes )
          if [ "$PRERELEASE" = "true" ]; then
            args+=( --prerelease )
          fi

          if [ "$UPLOAD_JAR" = "true" ]; then
            # dist contient exactement le jar choisi
            ls -la dist
            args+=( dist/*.jar )
          fi

          gh release create "${args[@]}"

  discord:
    runs-on: ubuntu-latest
    needs: build
    if: ${{ (github.event_name == 'push' || github.event_name == 'release') && needs.build.result == 'success' }}
    steps:
      - name: Envoyer message Discord
        shell: bash
        run: |
          set -euo pipefail

          WEBHOOK_URL="${{ secrets.DISCORD_WEBHOOK_URL }}"
          if [ -z "$WEBHOOK_URL" ]; then
            echo "Secret DISCORD_WEBHOOK_URL manquant."
            exit 1
          fi

          if [ "${{ github.event_name }}" = "push" ]; then
            AUTHOR="${{ github.actor }}"
            COMMIT_MSG="${{ github.event.head_commit.message }}"
            COMMIT_URL="${{ github.event.head_commit.url }}"
            VERSION="${{ needs.build.outputs.gradle_version }}"
            JAR="${{ needs.build.outputs.jar_name }}"

            CONTENT="$(printf '%s\n' \
              "‚úÖ **Build OK ‚Äî DeepstonePlugin**" \
              "üß© Version : $VERSION" \
              "üì¶ Jar : $JAR" \
              "üë§ $AUTHOR" \
              "üìù $COMMIT_MSG" \
              "üîó $COMMIT_URL")"
          fi

          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
            URL="${{ github.event.release.html_url }}"
            CHANGELOG="${{ github.event.release.body }}"
            [ -z "$CHANGELOG" ] && CHANGELOG="(pas de d√©tails)"

            CONTENT="$(printf '%s\n' \
              "‚úÖ **Release publi√©e : DeepstonePlugin**" \
              "üß© Version : $VERSION" \
              "" \
              "üìù Notes :" \
              "$CHANGELOG" \
              "" \
              "üîó $URL")"
          fi

          PAYLOAD=$(jq -n --arg content "$CONTENT" '{content: $content}')
          curl -sS -H "Content-Type: application/json" -d "$PAYLOAD" "$WEBHOOK_URL"
